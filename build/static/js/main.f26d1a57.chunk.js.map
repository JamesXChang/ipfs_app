{"version":3,"sources":["storehash.js","App.js","ipfs.js","serviceWorker.js","index.js","web3.js"],"names":["web3","eth","Contract","App","state","ipfsHash","buffer","ethAddress","blockNumber","transactionHash","gasUsed","txReceipt","ipfs_img","captureFile","event","stopPropagation","preventDefault","file","target","files","reader","window","FileReader","readAsArrayBuffer","onloadend","convertToBuffer","a","Buffer","from","result","setState","onClick","getTransactionReceipt","err","console","log","onSubmit","getAccounts","accounts","storehash","options","address","ipfs","add","hash","methods","setHash","send","error","className","class","this","type","onChange","bordered","responsive","scope","src","alt","width","height","Component","require","host","port","protocol","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","Web3","currentProvider"],"mappings":"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","file":"static/js/main.f26d1a57.chunk.js","sourcesContent":["import web3 from './web3';\n\nvar address = '0xF3D694B1cc97d72f095FAE628f7AbD1aFFB68B9D';\n\nvar abi = [\n\t{\n\t\t\"constant\": false,\n\t\t\"inputs\": [\n\t\t\t{\n\t\t\t\t\"name\": \"x\",\n\t\t\t\t\"type\": \"string\"\n\t\t\t}\n\t\t],\n\t\t\"name\": \"setHash\",\n\t\t\"outputs\": [],\n\t\t\"payable\": false,\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"function\"\n\t},\n\t{\n\t\t\"constant\": true,\n\t\t\"inputs\": [],\n\t\t\"name\": \"getHash\",\n\t\t\"outputs\": [\n\t\t\t{\n\t\t\t\t\"name\": \"x\",\n\t\t\t\t\"type\": \"string\"\n\t\t\t}\n\t\t],\n\t\t\"payable\": false,\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t}\n];\nexport default new web3.eth.Contract(abi, address);\n","import React, { Component } from 'react';\n//import logo from ‘./logo.svg’;\nimport './App.css';\nimport web3 from './web3';\nimport ipfs from './ipfs';\nimport storehash from './storehash';\n\n\nclass App extends Component {\n \n  state = {\n    ipfsHash:null,\n    buffer:'',\n    ethAddress:'',\n    blockNumber:'',\n    transactionHash:'',\n    gasUsed:'',\n    txReceipt: '',   \n    ipfs_img:null\n  };\n\n  captureFile =(event) => {\n    event.stopPropagation()\n    event.preventDefault()\n    const file = event.target.files[0]\n    let reader = new window.FileReader()\n    reader.readAsArrayBuffer(file)\n    reader.onloadend = () => this.convertToBuffer(reader)    \n  };\n\n  convertToBuffer = async(reader) => {\n    //file is converted to a buffer for upload to IPFS\n    const buffer = await Buffer.from(reader.result);\n\n    //set this buffer -using es6 syntax\n    this.setState({buffer});\n  };\n\n  onClick = async () => {\n    try{\n        this.setState({blockNumber:\"waiting..\"});\n        this.setState({gasUsed:\"waiting...\"});\n\n        //get Transaction Receipt in console on click\n        //See: https://web3js.readthedocs.io/en/1.0/web3-eth.html#gettransactionreceipt\n        await web3.eth.getTransactionReceipt(this.state.transactionHash, (err, txReceipt)=>{\n          console.log(err,txReceipt);\n          this.setState({txReceipt});\n        }); //await for getTransactionReceipt\n\n        await this.setState({blockNumber: this.state.txReceipt.blockNumber});\n        await this.setState({gasUsed: this.state.txReceipt.gasUsed});    \n    } //try\n    catch(error){\n        console.log(error);\n    } //catch\n  } //onClick\n\n  onSubmit = async (event) => {\n    event.preventDefault();\n    //bring in user's metamask account address\n    const accounts = await web3.eth.getAccounts();\n    \n    console.log('Sending from Metamask account: ' + accounts[0]);\n\n    //obtain contract address from storehash.js\n    const ethAddress= await storehash.options.address;\n    this.setState({ethAddress});\n\n    //save document to IPFS,return its hash#, and set hash# to state\n    //https://github.com/ipfs/interface-ipfs-core/blob/master/SPEC/FILES.md#add \n    await ipfs.add(this.state.buffer, (err, ipfsHash) => {\n      console.log(err,ipfsHash);\n      //setState by setting ipfsHash to ipfsHash[0].hash \n      this.setState({ ipfsHash:ipfsHash[0].hash });\n      const ipfs_img =\"https://gateway.ipfs.io/ipfs/\"+ipfsHash[0].hash;\n      console.log(err,ipfs_img);\n      this.setState({ipfs_img});\n      // ipfs_img = image('http://www.ghttps://gateway.ipfs.io/ipfs/QmRrwgD7JYq3CTZUrJ6WPKKxkwPCuKY5CL6wC8DyF6uDSfoogle.com/image.png');\n      \n      \n      // call Ethereum contract method \"setHash\" and .send IPFS hash to etheruem contract \n      //return the transaction hash from the ethereum contract\n      //see, this https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#methods-mymethod-send\n      storehash.methods.setHash(this.state.ipfsHash).send({\n        from: accounts[0] \n      }, (error, transactionHash) => {\n        console.log(transactionHash);\n        this.setState({transactionHash});\n      }); //storehash \n    }) //await ipfs.add \n  }; //onSubmit\n\n\n  render() {\n        \n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <h1> Ethereum and IPFS with Create React App</h1>\n        </header>\n        \n        <hr/>\n      <grid>\n        <h3> Choose file to send to IPFS </h3>\n        <div class=\"div_center\">\n          <form class=\"form-group\" onSubmit={this.onSubmit} >\n            <input type = \"file\" onChange = {this.captureFile} />\n            {/* <div class=\" col-md-2 col-x2-1\">  btn-block*/}\n              <button class=\"button_center btn btn-outline-primary cursor-pointer\" type=\"submit\"> Send it</button>\n            {/* </div> */}\n          </form>\n        </div>\n        <br></br>\n        <hr/>\n          <div class=\"div_center\">\n            <div class=\"col-md-3 col-x2-1\">\n              <button type=\"button\" class=\"button2 btn-block btn btn-outline-primary nofocus cursor-pointer\" onClick = {this.onClick}> Get Transaction Receipt </button>\n            </div>\n          <table class=\"table table-striped table-hover\" bordered responsive>\n              <thead>\n                <tr>\n                  <th scope=\"col\" class=\"col-md-3\" >Tx Receipt Category</th>\n                  <th scope=\"col\" class=\"col-md-3\">Values</th>\n                </tr>\n              </thead>\n              \n              <tbody>\n                <tr>\n                  <th scope=\"row\">IPFS Hash # stored on Eth Contract: </th>\n                  <td>{this.state.ipfsHash}</td>\n                </tr>\n                <tr>\n                  <th scope=\"row\">Ethereum Contract Address: </th>\n                  <td>{this.state.ethAddress}</td>\n                </tr>\n                <tr>\n                  <th scope=\"row\">Tx Hash # : </th>\n                  <td>{this.state.transactionHash}</td>\n                </tr>\n                <tr>\n                  <th scope=\"row\">Block Number # : </th>\n                  <td>{this.state.blockNumber}</td>\n                </tr>\n                <tr>\n                  <th scope=\"row\">Gas Used : </th>\n                  <td>{this.state.gasUsed}</td>\n                </tr>\n              \n              </tbody>\n          </table>\n          <h3>IPFS image</h3>\n          <iframe src={this.state.ipfs_img} alt=\"ipfs\" width=\"1000\" height=\"500\"/>\n          <br></br>\n          </div>\n      </grid>\n    </div>\n    );\n  } //render\n} //App\nexport default App;\n","const IPFS = require('ipfs-api');\nconst ipfs = new IPFS({ host: 'ipfs.infura.io', port: 5001, protocol: 'https' });\n\nexport default ipfs;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n//import registerServiceWorker from './registerServiceWorker';\n//import 'bootstrap/dist/css/bootstrap.min.css';\nimport '/Users/james/smart-contracts/node_modules/webgme/src/client/bower_components/bootstrap/dist/css/bootstrap.min.css';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n\n//registerServiceWorker();\n\n\n","import Web3 from 'web3';\n\nconst web3 = new Web3(window.web3.currentProvider);\n\nexport default web3;"],"sourceRoot":""}